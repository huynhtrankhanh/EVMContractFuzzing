const web3 = require('web3');
const solc = require("solc");
const { toWei } = require('web3-utils');
const { LegacyTransaction } = require('@ethereumjs/tx');
const { Common, Chain, Hardfork } = require('@ethereumjs/common');
const { VM } = require('@ethereumjs/vm');
const { Account, Address, privateToAddress, toBuffer } = require('@ethereumjs/util');
const keythereum = require("keythereum");
const privateKey = keythereum.create({ keyBytes: 32, ivBytes: 16 }).privateKey;
const senderAddress = Address.fromPrivateKey(privateKey);
const common = new Common({ chain: Chain.Mainnet, hardfork: Hardfork.London });
const fc = require("fast-check");
const fs = require('fs');
const { Block } = require("@ethereumjs/block");

async function main() {
    const contractCode = fs.readFileSync("./HamiltonianCycle.sol", { encoding: "utf8" });
    // Compile the contract
    const input = {
        language: 'Solidity',
        sources: {
            'HamiltonianCycle.sol': {
                content: contractCode,
            },
        },
        settings: {
            outputSelection: {
                '*': {
                    '*': ['abi', 'evm.bytecode'],
                },
            },
        },
    };

    const output = JSON.parse(solc.compile(JSON.stringify(input)));

    const abi = output.contracts['HamiltonianCycle.sol']['HamiltonianCycle'].abi;
    const bytecode = output.contracts['HamiltonianCycle.sol']['HamiltonianCycle'].evm.bytecode.object;

    const account = Account.fromAccountData({
      nonce: 0,
      balance: BigInt(toWei('1000000', 'ether')), // initial balance
    });

    const abiMap = new Map();

    for (const method of abi) {
        if (!method.name) continue; // useless constructor
        abiMap.set(method.name, method);
    }

    const setGraph = abiMap.get("setGraph");

    const processGraph = async (graph, nodeCount) => {
        const block = Block.fromBlockData({ header: { extraData: new Uint8Array(97) } }, { common });
        const vm = await VM.create({ common });
        await vm.stateManager.putAccount(senderAddress, account);
        const retrievedAccount = await vm.stateManager.getAccount(senderAddress);

        // Deploy the contract
        const getNonce = (() => {
            let nonce = Number(retrievedAccount.nonce);
            return () => nonce++;
        })();
        const deployTxData = {
            data: `0x${bytecode}`,
            gasLimit: 1000000n,
            gasPrice: BigInt(toWei('20', 'gwei')),
            nonce: getNonce()
        };

        const tx = LegacyTransaction.fromTxData(deployTxData, { common }).sign(privateKey);
        const receipt = await vm.runTx({ tx, block });

        const contractAddress = receipt.createdAddress;

        // Initialize the contract with 1000 ETH
        const depositTxData = {
            to: contractAddress,
            value: BigInt(toWei('1000', 'ether')),
            gasLimit: 1000000n,
            gasPrice: BigInt(toWei('20', 'gwei')),
            nonce: getNonce()
        };

        {
            const depositTx = LegacyTransaction.fromTxData(depositTxData, { common }).sign(privateKey);
            const receipt = await vm.runTx({ tx: depositTx, block });
            console.log(receipt);
        }

        for (let i = 0; i < 2; i++) {
            const setGraphTxData = {
                to: contractAddress,
                gasLimit: 1000000n,
                gasPrice: BigInt(toWei('20', 'gwei')),
                nonce: getNonce(),
                data: web3.eth.abi.encodeFunctionCall(setGraph, [nodeCount, graph])
            };

            const setGraphTx = LegacyTransaction.fromTxData(setGraphTxData, { common }).sign(privateKey);
            const receipt = await vm.runTx({ tx: setGraphTx, block });
            console.log(receipt);
        }

        return true;
    };

    fc.assert(fc.asyncProperty(fc.array(fc.tuple(fc.integer(0, 100), fc.integer(0, 100))), graph => {
        const unique = new Set();
        for (const [a, b] of graph) {
            unique.add(a);
            unique.add(b);
        }
        const map = new Map();
        for (const [index, value] of [...unique].entries()) {
            map.set(value, index);
        }
        for (const x of graph) {
            x[0] = map.get(x[0]);
            x[1] = map.get(x[1]);
        }

        const nodeCount = unique.size;
        return processGraph(graph, nodeCount);
    }));
}

main().catch(console.error);
